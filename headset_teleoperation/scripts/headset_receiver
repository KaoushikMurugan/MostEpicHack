#!/usr/bin/env python

import rospy
import json
import socket
from headset_teleoperation.msg import Headset
from tf2_ros import TransformBroadcaster
from geometry_msgs.msg import TransformStamped, Pose
from scipy.spatial.transform import Rotation as R
import numpy as np

TRANSFORM_TO_WORLD = np.eye(4)
TRANSFORM_TO_WORLD[:3, :3] = R.from_euler('xyz', [-90, 0, -90], degrees=True).as_matrix()

def convert_left_to_right_coordinates(left_pose):
    x = left_pose.position.x
    y = -left_pose.position.y # flip the y axis
    z = left_pose.position.z
    qx = -left_pose.orientation.x # flip rotation from left to right
    qy = left_pose.orientation.y
    qz = -left_pose.orientation.z # flip rotation from left to right
    qw = left_pose.orientation.w

    # transform to world coordinates
    transform = np.eye(4)
    transform[:3, :3] = R.from_quat([qx, qy, qz, qw]).as_matrix()
    transform[:3, 3] = np.array([x, y, z])
    transform = np.dot(TRANSFORM_TO_WORLD, transform)

    # create new pose
    right_pose = Pose()
    right_pose.position.x = transform[0, 3]
    right_pose.position.y = transform[1, 3]
    right_pose.position.z = transform[2, 3]
    q = R.from_matrix(transform[:3, :3]).as_quat()
    right_pose.orientation.x = q[0]
    right_pose.orientation.y = q[1]
    right_pose.orientation.z = q[2]
    right_pose.orientation.w = q[3]

    return right_pose

def broadcase_pose(tf_broadcaster, pose, frame_id, child_frame_id):
    # Create a TransformStamped message
    t = TransformStamped()

    # Set the header frame ID
    t.header.frame_id = frame_id

    # Set the child frame ID
    t.child_frame_id = child_frame_id

    # Set the transform translation
    t.transform.translation.x = pose.position.x
    t.transform.translation.y = pose.position.y
    t.transform.translation.z = pose.position.z

    # Set the transform rotation
    t.transform.rotation.x = pose.orientation.x
    t.transform.rotation.y = pose.orientation.y
    t.transform.rotation.z = pose.orientation.z
    t.transform.rotation.w = pose.orientation.w

    # Set the timestamp
    t.header.stamp = rospy.Time.now()

    # Broadcast the transform
    tf_broadcaster.sendTransform(t)

def main():
    # ROS node initialization
    rospy.init_node('headset_receiver')

    # Get the IP and port parameters
    ip = rospy.get_param('~ip', '172.19.248.37')
    port = rospy.get_param('~port', 5555)

    # Create a ROS publisher
    publisher = rospy.Publisher('headset', Headset, queue_size=10)

    # Create a TransformBroadcaster
    tf_broadcaster = TransformBroadcaster()

    # Create a UDP socket
    udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    # Bind the socket to computer's address 
    udp_socket.bind((ip, port))

    # Set a timeout for the socket (in seconds)
    udp_socket.settimeout(0.2)  # Adjust the timeout value as needed

    rate =  rospy.Rate(100) # 100 Hz

    while not rospy.is_shutdown():
        try:
            # Receive data from the socket with timeout
            data, addr = udp_socket.recvfrom(1024)

            # Decode the received bytes into a string
            received_json = data.decode('utf-8')

            # Parse the JSON string into a Python dictionary
            received_data = json.loads(received_json)

            msg = Headset()
            msg.h_pose.position.x = received_data['HPosition']['x']
            msg.h_pose.position.y = received_data['HPosition']['y']
            msg.h_pose.position.z = received_data['HPosition']['z']
            msg.h_pose.orientation.x = received_data['HRotation']['x']
            msg.h_pose.orientation.y = received_data['HRotation']['y']
            msg.h_pose.orientation.z = received_data['HRotation']['z']
            msg.h_pose.orientation.w = received_data['HRotation']['w']

            msg.l_pose.position.x = received_data['LPosition']['x']
            msg.l_pose.position.y = received_data['LPosition']['y']
            msg.l_pose.position.z = received_data['LPosition']['z']
            msg.l_pose.orientation.x = received_data['LRotation']['x']
            msg.l_pose.orientation.y = received_data['LRotation']['y']
            msg.l_pose.orientation.z = received_data['LRotation']['z']
            msg.l_pose.orientation.w = received_data['LRotation']['w']
            msg.l_thumbstick_x = received_data['LThumbstick']['x']
            msg.l_thumbstick_y = received_data['LThumbstick']['y']
            msg.l_index_trigger = received_data['LIndexTrigger']
            msg.l_hand_trigger = received_data['LHandTrigger']
            msg.l_button_one = received_data['LButtonOne']
            msg.l_button_two = received_data['LButtonTwo']
            msg.l_button_thumbstick = received_data['LButtonThumbstick']

            msg.r_pose.position.x = received_data['RPosition']['x']
            msg.r_pose.position.y = received_data['RPosition']['y']
            msg.r_pose.position.z = received_data['RPosition']['z']
            msg.r_pose.orientation.x = received_data['RRotation']['x']
            msg.r_pose.orientation.y = received_data['RRotation']['y']
            msg.r_pose.orientation.z = received_data['RRotation']['z']
            msg.r_pose.orientation.w = received_data['RRotation']['w']
            msg.r_thumbstick_x = received_data['RThumbstick']['x']
            msg.r_thumbstick_y = received_data['RThumbstick']['y']
            msg.r_index_trigger = received_data['RIndexTrigger']
            msg.r_hand_trigger = received_data['RHandTrigger']
            msg.r_button_one = received_data['RButtonOne']
            msg.r_button_two = received_data['RButtonTwo']
            msg.r_button_thumbstick = received_data['RButtonThumbstick']

            msg.h_pose = convert_left_to_right_coordinates(msg.h_pose)
            msg.l_pose = convert_left_to_right_coordinates(msg.l_pose)
            msg.r_pose = convert_left_to_right_coordinates(msg.r_pose)

            # Broadcast the headset and controller poses
            broadcase_pose(tf_broadcaster, msg.h_pose, "world", "headset")
            broadcase_pose(tf_broadcaster, msg.l_pose, "world", "left_controller")
            broadcase_pose(tf_broadcaster, msg.r_pose, "world", "right_controller")

            # Publish the message
            publisher.publish(msg)  

            rate.sleep()  

        except socket.timeout:
            # Handle timeout by continuing the loop
            print("Socket timeout. Retrying...")
            continue
        except json.JSONDecodeError:
            # Handle JSON decoding error by continuing the loop
            print("JSON decoding error. Retrying...")
            continue
        except KeyError as e:
            # Handle KeyError by continuing the loop
            print("Invalid JSON key:", e)
            continue

    # close the socket when the node is shutdown
    udp_socket.close()

if __name__ == "__main__":
    main()
